## Vt Language

Vt is a statically typed, compiled language with C-like syntax. The language supports signed integers and strings. Strings are null-terminated and mutable, but their length is immutable. Strings are represented as pointers to their starting position, with a maximum length of 255 characters. The compilation targets a custom assembly language for subsequent emulated execution on a RISC machine: https://github.com/asurkis/risc-emulator

The language provides the following features:

- Integer variable operations (comparison, assignment, and arithmetic)
- String operations (comparison by the first character, assignment, and concatenation)
- Logical operators: `and`, `or`, `not`
- Unary operators: `not` and unary minus
- Conditional if statement with an optional else block
- `while` loop
- `prints` and `printi` statements for outputting strings and integers, respectively
- Single-line and multi-line comments

The complete grammar is defined in the Vt.g4 file.

## Project Structure

The file order below reflects their usage sequence during the compilation process.

- `Vt.g4`: ANTLR grammar file for Vt language
- `frontend/Vt*`: Lexer and parser generated by ANTLR4
- `frontend/ast*`: AST construction without semantic analysis
- `frontend/semantic`: Semantic analyzer
- `frontend/utils/`: Utility functions, currently used for printing the AST to a specified output stream
- `middle/ir`: IR definition. The IR is a three-address code with an infinite number of virtual registers
- `middle/string_processing`: Expansion of string operations into IR. Strings are treated as stub pointers, and operations such as `prints` and comparisons are expanded into loops. `printi` (integer output) is also expanded at this stage to convert the number to a string and print it character by character in a loop.
- `middle/utils`: Utility functions, currently used for printing the IR to a specified output stream
- `backend/register_allocation`: Register allocator. The target assembly supports registers x1 to x31. This module implements the Linear Scan algorithm to map the unlimited number of virtual IR registers to a finite set of physical registers, using spill slots when needed. The algorithm is based on [this paper](https://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf).
- `backend/address_alloc`: Replacement of string address stubs in the IR with actual physical addresses
- `backend/asm_generation`: Generation of the target assembly code
- `frontend/tests`: Tests verifying the correctness of AST construction and semantic analysis
- `middle/tests`: Tests verifying the correctness of IR generation

## Examples

A complete set of examples, along with their corresponding IR, AST, and ASM outputs, is available in the `examples/` directory.

## How to Run

```
./vt-compiler <input_file.vt> <output_file>
```
This command will generate 4 files:

- `<output_file>_ast`: The AST of the input file
- `<output_file>_ir1`: The IR of the input file after string processing
- `<output_file>_ir2`: The IR of the input file after register and address allocation
- `<output_file>.asm`: The assembly code of the input file

## Dependencies

- [ANTLR4](https://www.antlr.org/) for parsing
- Google Test for unit testing

